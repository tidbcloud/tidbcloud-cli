/*
TiDB Cloud Serverless CDC Open API

TiDB Cloud Serverless CDC Open API

API version: v1beta1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cdc

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ChangefeedServiceAPIService ChangefeedServiceAPI service
type ChangefeedServiceAPIService service

type ApiChangefeedServiceCreateChangefeedRequest struct {
	ctx        context.Context
	ApiService *ChangefeedServiceAPIService
	clusterId  string
	body       *ChangefeedServiceCreateChangefeedBody
}

func (r ApiChangefeedServiceCreateChangefeedRequest) Body(body ChangefeedServiceCreateChangefeedBody) ApiChangefeedServiceCreateChangefeedRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceCreateChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceCreateChangefeedExecute(r)
}

/*
ChangefeedServiceCreateChangefeed Create a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceCreateChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceCreateChangefeed(ctx context.Context, clusterId string) ApiChangefeedServiceCreateChangefeedRequest {
	return ApiChangefeedServiceCreateChangefeedRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceCreateChangefeedExecute(r ApiChangefeedServiceCreateChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceCreateChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceCreatePrivateLinkEndpointRequest struct {
	ctx        context.Context
	ApiService *ChangefeedServiceAPIService
	clusterId  string
	body       *ChangefeedServiceCreatePrivateLinkEndpointBody
}

func (r ApiChangefeedServiceCreatePrivateLinkEndpointRequest) Body(body ChangefeedServiceCreatePrivateLinkEndpointBody) ApiChangefeedServiceCreatePrivateLinkEndpointRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceCreatePrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ChangefeedServiceCreatePrivateLinkEndpointExecute(r)
}

/*
ChangefeedServiceCreatePrivateLinkEndpoint Create a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceCreatePrivateLinkEndpointRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceCreatePrivateLinkEndpoint(ctx context.Context, clusterId string) ApiChangefeedServiceCreatePrivateLinkEndpointRequest {
	return ApiChangefeedServiceCreatePrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ChangefeedServiceAPIService) ChangefeedServiceCreatePrivateLinkEndpointExecute(r ApiChangefeedServiceCreatePrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceCreatePrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/private-link-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceDeleteChangefeedRequest struct {
	ctx          context.Context
	ApiService   *ChangefeedServiceAPIService
	clusterId    string
	changefeedId string
}

func (r ApiChangefeedServiceDeleteChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceDeleteChangefeedExecute(r)
}

/*
ChangefeedServiceDeleteChangefeed Delete a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param changefeedId Required. The ID of the changefeed.
	@return ApiChangefeedServiceDeleteChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceDeleteChangefeed(ctx context.Context, clusterId string, changefeedId string) ApiChangefeedServiceDeleteChangefeedRequest {
	return ApiChangefeedServiceDeleteChangefeedRequest{
		ApiService:   a,
		ctx:          ctx,
		clusterId:    clusterId,
		changefeedId: changefeedId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceDeleteChangefeedExecute(r ApiChangefeedServiceDeleteChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceDeleteChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/{changefeedId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changefeedId"+"}", url.PathEscape(parameterValueToString(r.changefeedId, "changefeedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceDeletePrivateLinkEndpointRequest struct {
	ctx                    context.Context
	ApiService             *ChangefeedServiceAPIService
	clusterId              string
	privateLinkServiceName *string
}

// Required. The private link service name.
func (r ApiChangefeedServiceDeletePrivateLinkEndpointRequest) PrivateLinkServiceName(privateLinkServiceName string) ApiChangefeedServiceDeletePrivateLinkEndpointRequest {
	r.privateLinkServiceName = &privateLinkServiceName
	return r
}

func (r ApiChangefeedServiceDeletePrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ChangefeedServiceDeletePrivateLinkEndpointExecute(r)
}

/*
ChangefeedServiceDeletePrivateLinkEndpoint Delete a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceDeletePrivateLinkEndpointRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceDeletePrivateLinkEndpoint(ctx context.Context, clusterId string) ApiChangefeedServiceDeletePrivateLinkEndpointRequest {
	return ApiChangefeedServiceDeletePrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ChangefeedServiceAPIService) ChangefeedServiceDeletePrivateLinkEndpointExecute(r ApiChangefeedServiceDeletePrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceDeletePrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/private-links-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.privateLinkServiceName == nil {
		return localVarReturnValue, nil, reportError("privateLinkServiceName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "privateLinkServiceName", r.privateLinkServiceName, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceDescribeSchemaTableRequest struct {
	ctx        context.Context
	ApiService *ChangefeedServiceAPIService
	clusterId  string
	body       *ChangefeedServiceDescribeSchemaTableBody
}

func (r ApiChangefeedServiceDescribeSchemaTableRequest) Body(body ChangefeedServiceDescribeSchemaTableBody) ApiChangefeedServiceDescribeSchemaTableRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceDescribeSchemaTableRequest) Execute() (*DescribeSchemaTableResp, *http.Response, error) {
	return r.ApiService.ChangefeedServiceDescribeSchemaTableExecute(r)
}

/*
ChangefeedServiceDescribeSchemaTable Describe schema table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceDescribeSchemaTableRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceDescribeSchemaTable(ctx context.Context, clusterId string) ApiChangefeedServiceDescribeSchemaTableRequest {
	return ApiChangefeedServiceDescribeSchemaTableRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return DescribeSchemaTableResp
func (a *ChangefeedServiceAPIService) ChangefeedServiceDescribeSchemaTableExecute(r ApiChangefeedServiceDescribeSchemaTableRequest) (*DescribeSchemaTableResp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DescribeSchemaTableResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceDescribeSchemaTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds:describeSchemaTable"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceEditChangefeedRequest struct {
	ctx          context.Context
	ApiService   *ChangefeedServiceAPIService
	clusterId    string
	changefeedId string
	body         *ChangefeedServiceEditChangefeedBody
}

func (r ApiChangefeedServiceEditChangefeedRequest) Body(body ChangefeedServiceEditChangefeedBody) ApiChangefeedServiceEditChangefeedRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceEditChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceEditChangefeedExecute(r)
}

/*
ChangefeedServiceEditChangefeed Edit a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param changefeedId Required. The ID of the changefeed.
	@return ApiChangefeedServiceEditChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceEditChangefeed(ctx context.Context, clusterId string, changefeedId string) ApiChangefeedServiceEditChangefeedRequest {
	return ApiChangefeedServiceEditChangefeedRequest{
		ApiService:   a,
		ctx:          ctx,
		clusterId:    clusterId,
		changefeedId: changefeedId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceEditChangefeedExecute(r ApiChangefeedServiceEditChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceEditChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/{changefeedId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changefeedId"+"}", url.PathEscape(parameterValueToString(r.changefeedId, "changefeedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceGetChangefeedRequest struct {
	ctx          context.Context
	ApiService   *ChangefeedServiceAPIService
	clusterId    string
	changefeedId string
}

func (r ApiChangefeedServiceGetChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceGetChangefeedExecute(r)
}

/*
ChangefeedServiceGetChangefeed Get a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param changefeedId Required. The ID of the changefeed.
	@return ApiChangefeedServiceGetChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceGetChangefeed(ctx context.Context, clusterId string, changefeedId string) ApiChangefeedServiceGetChangefeedRequest {
	return ApiChangefeedServiceGetChangefeedRequest{
		ApiService:   a,
		ctx:          ctx,
		clusterId:    clusterId,
		changefeedId: changefeedId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceGetChangefeedExecute(r ApiChangefeedServiceGetChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceGetChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/{changefeedId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changefeedId"+"}", url.PathEscape(parameterValueToString(r.changefeedId, "changefeedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceGetPrivateLinkEndpointRequest struct {
	ctx                    context.Context
	ApiService             *ChangefeedServiceAPIService
	clusterId              string
	privateLinkServiceName *string
}

// Required. The private link service name.
func (r ApiChangefeedServiceGetPrivateLinkEndpointRequest) PrivateLinkServiceName(privateLinkServiceName string) ApiChangefeedServiceGetPrivateLinkEndpointRequest {
	r.privateLinkServiceName = &privateLinkServiceName
	return r
}

func (r ApiChangefeedServiceGetPrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ChangefeedServiceGetPrivateLinkEndpointExecute(r)
}

/*
ChangefeedServiceGetPrivateLinkEndpoint Get a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceGetPrivateLinkEndpointRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceGetPrivateLinkEndpoint(ctx context.Context, clusterId string) ApiChangefeedServiceGetPrivateLinkEndpointRequest {
	return ApiChangefeedServiceGetPrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ChangefeedServiceAPIService) ChangefeedServiceGetPrivateLinkEndpointExecute(r ApiChangefeedServiceGetPrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceGetPrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/private-links-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.privateLinkServiceName == nil {
		return localVarReturnValue, nil, reportError("privateLinkServiceName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "privateLinkServiceName", r.privateLinkServiceName, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceListChangefeedsRequest struct {
	ctx            context.Context
	ApiService     *ChangefeedServiceAPIService
	clusterId      string
	pageSize       *int32
	pageToken      *string
	changefeedType *ChangefeedServiceListChangefeedsChangefeedTypeParameter
	orderBy        *string
}

// Optional. The maximum number of changefeeds to return. Default is 10.
func (r ApiChangefeedServiceListChangefeedsRequest) PageSize(pageSize int32) ApiChangefeedServiceListChangefeedsRequest {
	r.pageSize = &pageSize
	return r
}

// Optional. The page token from the previous response for pagination.
func (r ApiChangefeedServiceListChangefeedsRequest) PageToken(pageToken string) ApiChangefeedServiceListChangefeedsRequest {
	r.pageToken = &pageToken
	return r
}

// Optional. The type of the changefeed. DEFAULT is all.   - KAFKA: Kafka changefeed type.  - MYSQL: MySQL changefeed type.
func (r ApiChangefeedServiceListChangefeedsRequest) ChangefeedType(changefeedType ChangefeedServiceListChangefeedsChangefeedTypeParameter) ApiChangefeedServiceListChangefeedsRequest {
	r.changefeedType = &changefeedType
	return r
}

// Optional. List changefeeds order by, separated by comma, default is ascending. Example: \&quot;create_time, bar desc\&quot;. Supported field: create_time
func (r ApiChangefeedServiceListChangefeedsRequest) OrderBy(orderBy string) ApiChangefeedServiceListChangefeedsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiChangefeedServiceListChangefeedsRequest) Execute() (*Changefeeds, *http.Response, error) {
	return r.ApiService.ChangefeedServiceListChangefeedsExecute(r)
}

/*
ChangefeedServiceListChangefeeds List changefeeds.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceListChangefeedsRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceListChangefeeds(ctx context.Context, clusterId string) ApiChangefeedServiceListChangefeedsRequest {
	return ApiChangefeedServiceListChangefeedsRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return Changefeeds
func (a *ChangefeedServiceAPIService) ChangefeedServiceListChangefeedsExecute(r ApiChangefeedServiceListChangefeedsRequest) (*Changefeeds, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeeds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceListChangefeeds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "", "")
	}
	if r.changefeedType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changefeedType", r.changefeedType, "", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceStartChangefeedRequest struct {
	ctx          context.Context
	ApiService   *ChangefeedServiceAPIService
	clusterId    string
	changefeedId string
	body         *map[string]interface{}
}

func (r ApiChangefeedServiceStartChangefeedRequest) Body(body map[string]interface{}) ApiChangefeedServiceStartChangefeedRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceStartChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceStartChangefeedExecute(r)
}

/*
ChangefeedServiceStartChangefeed Start a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param changefeedId Required. The ID of the changefeed.
	@return ApiChangefeedServiceStartChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceStartChangefeed(ctx context.Context, clusterId string, changefeedId string) ApiChangefeedServiceStartChangefeedRequest {
	return ApiChangefeedServiceStartChangefeedRequest{
		ApiService:   a,
		ctx:          ctx,
		clusterId:    clusterId,
		changefeedId: changefeedId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceStartChangefeedExecute(r ApiChangefeedServiceStartChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceStartChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/{changefeedId}:start"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changefeedId"+"}", url.PathEscape(parameterValueToString(r.changefeedId, "changefeedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceStopChangefeedRequest struct {
	ctx          context.Context
	ApiService   *ChangefeedServiceAPIService
	clusterId    string
	changefeedId string
	body         *map[string]interface{}
}

func (r ApiChangefeedServiceStopChangefeedRequest) Body(body map[string]interface{}) ApiChangefeedServiceStopChangefeedRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceStopChangefeedRequest) Execute() (*Changefeed, *http.Response, error) {
	return r.ApiService.ChangefeedServiceStopChangefeedExecute(r)
}

/*
ChangefeedServiceStopChangefeed Stop a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param changefeedId Required. The ID of the changefeed.
	@return ApiChangefeedServiceStopChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceStopChangefeed(ctx context.Context, clusterId string, changefeedId string) ApiChangefeedServiceStopChangefeedRequest {
	return ApiChangefeedServiceStopChangefeedRequest{
		ApiService:   a,
		ctx:          ctx,
		clusterId:    clusterId,
		changefeedId: changefeedId,
	}
}

// Execute executes the request
//
//	@return Changefeed
func (a *ChangefeedServiceAPIService) ChangefeedServiceStopChangefeedExecute(r ApiChangefeedServiceStopChangefeedRequest) (*Changefeed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Changefeed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceStopChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds/{changefeedId}:stop"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"changefeedId"+"}", url.PathEscape(parameterValueToString(r.changefeedId, "changefeedId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangefeedServiceTestChangefeedRequest struct {
	ctx        context.Context
	ApiService *ChangefeedServiceAPIService
	clusterId  string
	body       *ChangefeedServiceTestChangefeedBody
}

func (r ApiChangefeedServiceTestChangefeedRequest) Body(body ChangefeedServiceTestChangefeedBody) ApiChangefeedServiceTestChangefeedRequest {
	r.body = &body
	return r
}

func (r ApiChangefeedServiceTestChangefeedRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChangefeedServiceTestChangefeedExecute(r)
}

/*
ChangefeedServiceTestChangefeed Test a changefeed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiChangefeedServiceTestChangefeedRequest
*/
func (a *ChangefeedServiceAPIService) ChangefeedServiceTestChangefeed(ctx context.Context, clusterId string) ApiChangefeedServiceTestChangefeedRequest {
	return ApiChangefeedServiceTestChangefeedRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ChangefeedServiceAPIService) ChangefeedServiceTestChangefeedExecute(r ApiChangefeedServiceTestChangefeedRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChangefeedServiceAPIService.ChangefeedServiceTestChangefeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/changefeeds:test"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
