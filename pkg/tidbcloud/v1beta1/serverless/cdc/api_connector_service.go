/*
TiDB Cloud Serverless CDC Open API

TiDB Cloud Serverless CDC Open API

API version: v1beta1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cdc

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ConnectorServiceAPIService ConnectorServiceAPI service
type ConnectorServiceAPIService service

type ApiConnectorServiceCreateConnectorRequest struct {
	ctx        context.Context
	ApiService *ConnectorServiceAPIService
	clusterId  string
	body       *ConnectorServiceCreateConnectorBody
}

func (r ApiConnectorServiceCreateConnectorRequest) Body(body ConnectorServiceCreateConnectorBody) ApiConnectorServiceCreateConnectorRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceCreateConnectorRequest) Execute() (*ConnectorID, *http.Response, error) {
	return r.ApiService.ConnectorServiceCreateConnectorExecute(r)
}

/*
ConnectorServiceCreateConnector Create a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceCreateConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceCreateConnector(ctx context.Context, clusterId string) ApiConnectorServiceCreateConnectorRequest {
	return ApiConnectorServiceCreateConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return ConnectorID
func (a *ConnectorServiceAPIService) ConnectorServiceCreateConnectorExecute(r ApiConnectorServiceCreateConnectorRequest) (*ConnectorID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceCreateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceCreatePrivateLinkEndpointRequest struct {
	ctx        context.Context
	ApiService *ConnectorServiceAPIService
	clusterId  string
	body       *ConnectorServiceCreatePrivateLinkEndpointBody
}

func (r ApiConnectorServiceCreatePrivateLinkEndpointRequest) Body(body ConnectorServiceCreatePrivateLinkEndpointBody) ApiConnectorServiceCreatePrivateLinkEndpointRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceCreatePrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ConnectorServiceCreatePrivateLinkEndpointExecute(r)
}

/*
ConnectorServiceCreatePrivateLinkEndpoint Create a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceCreatePrivateLinkEndpointRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceCreatePrivateLinkEndpoint(ctx context.Context, clusterId string) ApiConnectorServiceCreatePrivateLinkEndpointRequest {
	return ApiConnectorServiceCreatePrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ConnectorServiceAPIService) ConnectorServiceCreatePrivateLinkEndpointExecute(r ApiConnectorServiceCreatePrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceCreatePrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/private-link-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceDeleteConnectorRequest struct {
	ctx         context.Context
	ApiService  *ConnectorServiceAPIService
	clusterId   string
	connectorId string
}

func (r ApiConnectorServiceDeleteConnectorRequest) Execute() (*ConnectorID, *http.Response, error) {
	return r.ApiService.ConnectorServiceDeleteConnectorExecute(r)
}

/*
ConnectorServiceDeleteConnector Delete a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param connectorId Required. The ID of the connector.
	@return ApiConnectorServiceDeleteConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceDeleteConnector(ctx context.Context, clusterId string, connectorId string) ApiConnectorServiceDeleteConnectorRequest {
	return ApiConnectorServiceDeleteConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		connectorId: connectorId,
	}
}

// Execute executes the request
//
//	@return ConnectorID
func (a *ConnectorServiceAPIService) ConnectorServiceDeleteConnectorExecute(r ApiConnectorServiceDeleteConnectorRequest) (*ConnectorID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceDeleteConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceDeletePrivateLinkEndpointRequest struct {
	ctx                    context.Context
	ApiService             *ConnectorServiceAPIService
	clusterId              string
	privateLinkServiceName *string
}

// Required. The private link service name.
func (r ApiConnectorServiceDeletePrivateLinkEndpointRequest) PrivateLinkServiceName(privateLinkServiceName string) ApiConnectorServiceDeletePrivateLinkEndpointRequest {
	r.privateLinkServiceName = &privateLinkServiceName
	return r
}

func (r ApiConnectorServiceDeletePrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ConnectorServiceDeletePrivateLinkEndpointExecute(r)
}

/*
ConnectorServiceDeletePrivateLinkEndpoint Delete a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceDeletePrivateLinkEndpointRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceDeletePrivateLinkEndpoint(ctx context.Context, clusterId string) ApiConnectorServiceDeletePrivateLinkEndpointRequest {
	return ApiConnectorServiceDeletePrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ConnectorServiceAPIService) ConnectorServiceDeletePrivateLinkEndpointExecute(r ApiConnectorServiceDeletePrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceDeletePrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/private-links-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.privateLinkServiceName == nil {
		return localVarReturnValue, nil, reportError("privateLinkServiceName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "privateLinkServiceName", r.privateLinkServiceName, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceDescribeSchemaTableRequest struct {
	ctx        context.Context
	ApiService *ConnectorServiceAPIService
	clusterId  string
	body       *ConnectorServiceDescribeSchemaTableBody
}

func (r ApiConnectorServiceDescribeSchemaTableRequest) Body(body ConnectorServiceDescribeSchemaTableBody) ApiConnectorServiceDescribeSchemaTableRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceDescribeSchemaTableRequest) Execute() (*DescribeSchemaTableResp, *http.Response, error) {
	return r.ApiService.ConnectorServiceDescribeSchemaTableExecute(r)
}

/*
ConnectorServiceDescribeSchemaTable Describe schema table.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceDescribeSchemaTableRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceDescribeSchemaTable(ctx context.Context, clusterId string) ApiConnectorServiceDescribeSchemaTableRequest {
	return ApiConnectorServiceDescribeSchemaTableRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return DescribeSchemaTableResp
func (a *ConnectorServiceAPIService) ConnectorServiceDescribeSchemaTableExecute(r ApiConnectorServiceDescribeSchemaTableRequest) (*DescribeSchemaTableResp, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DescribeSchemaTableResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceDescribeSchemaTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors:describeSchemaTable"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceEditConnectorRequest struct {
	ctx         context.Context
	ApiService  *ConnectorServiceAPIService
	clusterId   string
	connectorId string
	body        *ConnectorServiceEditConnectorBody
}

func (r ApiConnectorServiceEditConnectorRequest) Body(body ConnectorServiceEditConnectorBody) ApiConnectorServiceEditConnectorRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceEditConnectorRequest) Execute() (*ConnectorID, *http.Response, error) {
	return r.ApiService.ConnectorServiceEditConnectorExecute(r)
}

/*
ConnectorServiceEditConnector Edit a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param connectorId Required. The ID of the connector.
	@return ApiConnectorServiceEditConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceEditConnector(ctx context.Context, clusterId string, connectorId string) ApiConnectorServiceEditConnectorRequest {
	return ApiConnectorServiceEditConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		connectorId: connectorId,
	}
}

// Execute executes the request
//
//	@return ConnectorID
func (a *ConnectorServiceAPIService) ConnectorServiceEditConnectorExecute(r ApiConnectorServiceEditConnectorRequest) (*ConnectorID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceEditConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/{connectorId}:edit"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceGetConnectorRequest struct {
	ctx         context.Context
	ApiService  *ConnectorServiceAPIService
	clusterId   string
	connectorId string
}

func (r ApiConnectorServiceGetConnectorRequest) Execute() (*Connector, *http.Response, error) {
	return r.ApiService.ConnectorServiceGetConnectorExecute(r)
}

/*
ConnectorServiceGetConnector Get a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param connectorId Required. The ID of the connector.
	@return ApiConnectorServiceGetConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceGetConnector(ctx context.Context, clusterId string, connectorId string) ApiConnectorServiceGetConnectorRequest {
	return ApiConnectorServiceGetConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		connectorId: connectorId,
	}
}

// Execute executes the request
//
//	@return Connector
func (a *ConnectorServiceAPIService) ConnectorServiceGetConnectorExecute(r ApiConnectorServiceGetConnectorRequest) (*Connector, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Connector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceGetConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceGetPrivateLinkEndpointRequest struct {
	ctx                    context.Context
	ApiService             *ConnectorServiceAPIService
	clusterId              string
	privateLinkServiceName *string
}

// Required. The private link service name.
func (r ApiConnectorServiceGetPrivateLinkEndpointRequest) PrivateLinkServiceName(privateLinkServiceName string) ApiConnectorServiceGetPrivateLinkEndpointRequest {
	r.privateLinkServiceName = &privateLinkServiceName
	return r
}

func (r ApiConnectorServiceGetPrivateLinkEndpointRequest) Execute() (*PrivateLinkEndpoint, *http.Response, error) {
	return r.ApiService.ConnectorServiceGetPrivateLinkEndpointExecute(r)
}

/*
ConnectorServiceGetPrivateLinkEndpoint Get a private link

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceGetPrivateLinkEndpointRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceGetPrivateLinkEndpoint(ctx context.Context, clusterId string) ApiConnectorServiceGetPrivateLinkEndpointRequest {
	return ApiConnectorServiceGetPrivateLinkEndpointRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return PrivateLinkEndpoint
func (a *ConnectorServiceAPIService) ConnectorServiceGetPrivateLinkEndpointExecute(r ApiConnectorServiceGetPrivateLinkEndpointRequest) (*PrivateLinkEndpoint, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PrivateLinkEndpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceGetPrivateLinkEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/private-links-endpoints"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.privateLinkServiceName == nil {
		return localVarReturnValue, nil, reportError("privateLinkServiceName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "privateLinkServiceName", r.privateLinkServiceName, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceListConnectorsRequest struct {
	ctx           context.Context
	ApiService    *ConnectorServiceAPIService
	clusterId     string
	pageSize      *int32
	pageToken     *string
	connectorType *ConnectorServiceListConnectorsConnectorTypeParameter
	orderBy       *string
}

// Optional. The maximum number of connectors to return. Default is 10.
func (r ApiConnectorServiceListConnectorsRequest) PageSize(pageSize int32) ApiConnectorServiceListConnectorsRequest {
	r.pageSize = &pageSize
	return r
}

// Optional. The page token from the previous response for pagination.
func (r ApiConnectorServiceListConnectorsRequest) PageToken(pageToken string) ApiConnectorServiceListConnectorsRequest {
	r.pageToken = &pageToken
	return r
}

// Optional. The type of the connector. DEFAULT is all.   - KAFKA: Kafka connector type.
func (r ApiConnectorServiceListConnectorsRequest) ConnectorType(connectorType ConnectorServiceListConnectorsConnectorTypeParameter) ApiConnectorServiceListConnectorsRequest {
	r.connectorType = &connectorType
	return r
}

// Optional. List connectors order by, separated by comma, default is ascending. Example: \&quot;create_time, bar desc\&quot;. Supported field: create_time
func (r ApiConnectorServiceListConnectorsRequest) OrderBy(orderBy string) ApiConnectorServiceListConnectorsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiConnectorServiceListConnectorsRequest) Execute() (*Connectors, *http.Response, error) {
	return r.ApiService.ConnectorServiceListConnectorsExecute(r)
}

/*
ConnectorServiceListConnectors List connectors.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceListConnectorsRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceListConnectors(ctx context.Context, clusterId string) ApiConnectorServiceListConnectorsRequest {
	return ApiConnectorServiceListConnectorsRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return Connectors
func (a *ConnectorServiceAPIService) ConnectorServiceListConnectorsExecute(r ApiConnectorServiceListConnectorsRequest) (*Connectors, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Connectors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceListConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "", "")
	}
	if r.connectorType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectorType", r.connectorType, "", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceStartConnectorRequest struct {
	ctx         context.Context
	ApiService  *ConnectorServiceAPIService
	clusterId   string
	connectorId string
	body        *map[string]interface{}
}

func (r ApiConnectorServiceStartConnectorRequest) Body(body map[string]interface{}) ApiConnectorServiceStartConnectorRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceStartConnectorRequest) Execute() (*ConnectorID, *http.Response, error) {
	return r.ApiService.ConnectorServiceStartConnectorExecute(r)
}

/*
ConnectorServiceStartConnector Start a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param connectorId Required. The ID of the connector.
	@return ApiConnectorServiceStartConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceStartConnector(ctx context.Context, clusterId string, connectorId string) ApiConnectorServiceStartConnectorRequest {
	return ApiConnectorServiceStartConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		connectorId: connectorId,
	}
}

// Execute executes the request
//
//	@return ConnectorID
func (a *ConnectorServiceAPIService) ConnectorServiceStartConnectorExecute(r ApiConnectorServiceStartConnectorRequest) (*ConnectorID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceStartConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/{connectorId}:start"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceStopConnectorRequest struct {
	ctx         context.Context
	ApiService  *ConnectorServiceAPIService
	clusterId   string
	connectorId string
	body        *map[string]interface{}
}

func (r ApiConnectorServiceStopConnectorRequest) Body(body map[string]interface{}) ApiConnectorServiceStopConnectorRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceStopConnectorRequest) Execute() (*ConnectorID, *http.Response, error) {
	return r.ApiService.ConnectorServiceStopConnectorExecute(r)
}

/*
ConnectorServiceStopConnector Stop a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@param connectorId Required. The ID of the connector.
	@return ApiConnectorServiceStopConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceStopConnector(ctx context.Context, clusterId string, connectorId string) ApiConnectorServiceStopConnectorRequest {
	return ApiConnectorServiceStopConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		clusterId:   clusterId,
		connectorId: connectorId,
	}
}

// Execute executes the request
//
//	@return ConnectorID
func (a *ConnectorServiceAPIService) ConnectorServiceStopConnectorExecute(r ApiConnectorServiceStopConnectorRequest) (*ConnectorID, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorID
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceStopConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors/{connectorId}:stop"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConnectorServiceTestConnectorRequest struct {
	ctx        context.Context
	ApiService *ConnectorServiceAPIService
	clusterId  string
	body       *ConnectorServiceTestConnectorBody
}

func (r ApiConnectorServiceTestConnectorRequest) Body(body ConnectorServiceTestConnectorBody) ApiConnectorServiceTestConnectorRequest {
	r.body = &body
	return r
}

func (r ApiConnectorServiceTestConnectorRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ConnectorServiceTestConnectorExecute(r)
}

/*
ConnectorServiceTestConnector Test a connector.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster.
	@return ApiConnectorServiceTestConnectorRequest
*/
func (a *ConnectorServiceAPIService) ConnectorServiceTestConnector(ctx context.Context, clusterId string) ApiConnectorServiceTestConnectorRequest {
	return ApiConnectorServiceTestConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ConnectorServiceAPIService) ConnectorServiceTestConnectorExecute(r ApiConnectorServiceTestConnectorRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorServiceAPIService.ConnectorServiceTestConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1beta1/clusters/{clusterId}/connectors:test"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v Status
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
