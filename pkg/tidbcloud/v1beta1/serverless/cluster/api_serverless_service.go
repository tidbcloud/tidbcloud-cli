/*
TiDB Cloud Serverless Open API

TiDB Cloud Serverless Open API

API version: v1beta1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cluster

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ServerlessServiceAPIService ServerlessServiceAPI service
type ServerlessServiceAPIService service

type ApiServerlessServiceChangeRootPasswordRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
	clusterId  string
	body       *ServerlessServiceChangeRootPasswordBody
}

func (r ApiServerlessServiceChangeRootPasswordRequest) Body(body ServerlessServiceChangeRootPasswordBody) ApiServerlessServiceChangeRootPasswordRequest {
	r.body = &body
	return r
}

func (r ApiServerlessServiceChangeRootPasswordRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ServerlessServiceChangeRootPasswordExecute(r)
}

/*
ServerlessServiceChangeRootPassword Changes the root password of a specific TiDB Serverless cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster for which the password is to be changed.
	@return ApiServerlessServiceChangeRootPasswordRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceChangeRootPassword(ctx context.Context, clusterId string) ApiServerlessServiceChangeRootPasswordRequest {
	return ApiServerlessServiceChangeRootPasswordRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *ServerlessServiceAPIService) ServerlessServiceChangeRootPasswordExecute(r ApiServerlessServiceChangeRootPasswordRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceChangeRootPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters/{clusterId}/password"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServiceCreateClusterRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
	cluster    *TidbCloudOpenApiserverlessv1beta1Cluster
}

// Required. The cluster to be created.
func (r ApiServerlessServiceCreateClusterRequest) Cluster(cluster TidbCloudOpenApiserverlessv1beta1Cluster) ApiServerlessServiceCreateClusterRequest {
	r.cluster = &cluster
	return r
}

func (r ApiServerlessServiceCreateClusterRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	return r.ApiService.ServerlessServiceCreateClusterExecute(r)
}

/*
ServerlessServiceCreateCluster Creates a new TiDB Serverless cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServerlessServiceCreateClusterRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceCreateCluster(ctx context.Context) ApiServerlessServiceCreateClusterRequest {
	return ApiServerlessServiceCreateClusterRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1Cluster
func (a *ServerlessServiceAPIService) ServerlessServiceCreateClusterExecute(r ApiServerlessServiceCreateClusterRequest) (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceCreateCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cluster == nil {
		return localVarReturnValue, nil, reportError("cluster is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cluster
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServiceDeleteClusterRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
	clusterId  string
}

func (r ApiServerlessServiceDeleteClusterRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	return r.ApiService.ServerlessServiceDeleteClusterExecute(r)
}

/*
ServerlessServiceDeleteCluster Deletes a specific TiDB Serverless cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster to be deleted.
	@return ApiServerlessServiceDeleteClusterRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceDeleteCluster(ctx context.Context, clusterId string) ApiServerlessServiceDeleteClusterRequest {
	return ApiServerlessServiceDeleteClusterRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1Cluster
func (a *ServerlessServiceAPIService) ServerlessServiceDeleteClusterExecute(r ApiServerlessServiceDeleteClusterRequest) (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceDeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters/{clusterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServiceGetClusterRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
	clusterId  string
	view       *ServerlessServiceGetClusterViewParameter
}

// Optional. The level of detail to return for the cluster.   - BASIC: Only basic information about the cluster is returned.  - FULL: All details about the cluster are returned.
func (r ApiServerlessServiceGetClusterRequest) View(view ServerlessServiceGetClusterViewParameter) ApiServerlessServiceGetClusterRequest {
	r.view = &view
	return r
}

func (r ApiServerlessServiceGetClusterRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	return r.ApiService.ServerlessServiceGetClusterExecute(r)
}

/*
ServerlessServiceGetCluster Retrieves details of a specific TiDB Serverless cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterId Required. The ID of the cluster to be retrieved.
	@return ApiServerlessServiceGetClusterRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceGetCluster(ctx context.Context, clusterId string) ApiServerlessServiceGetClusterRequest {
	return ApiServerlessServiceGetClusterRequest{
		ApiService: a,
		ctx:        ctx,
		clusterId:  clusterId,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1Cluster
func (a *ServerlessServiceAPIService) ServerlessServiceGetClusterExecute(r ApiServerlessServiceGetClusterRequest) (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceGetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters/{clusterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterId, "clusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.view != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view", r.view, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServiceListClustersRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
	pageSize   *int32
	pageToken  *string
	filter     *string
	orderBy    *string
	skip       *int32
}

// Optional. The maximum number of clusters to return.
func (r ApiServerlessServiceListClustersRequest) PageSize(pageSize int32) ApiServerlessServiceListClustersRequest {
	r.pageSize = &pageSize
	return r
}

// Optional. The page token from the previous response for pagination.
func (r ApiServerlessServiceListClustersRequest) PageToken(pageToken string) ApiServerlessServiceListClustersRequest {
	r.pageToken = &pageToken
	return r
}

// Optional. The filter expression to filter clusters.
func (r ApiServerlessServiceListClustersRequest) Filter(filter string) ApiServerlessServiceListClustersRequest {
	r.filter = &filter
	return r
}

// Optional. The order by expression for sorting clusters.
func (r ApiServerlessServiceListClustersRequest) OrderBy(orderBy string) ApiServerlessServiceListClustersRequest {
	r.orderBy = &orderBy
	return r
}

// The number of individual resources to skip before starting to return results. If the skip value causes the cursor to move past the end of the collection, the response will be 200 OK with an empty result set and no next_page_token.
func (r ApiServerlessServiceListClustersRequest) Skip(skip int32) ApiServerlessServiceListClustersRequest {
	r.skip = &skip
	return r
}

func (r ApiServerlessServiceListClustersRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1ListClustersResponse, *http.Response, error) {
	return r.ApiService.ServerlessServiceListClustersExecute(r)
}

/*
ServerlessServiceListClusters Provides a list of TiDB Serverless clusters in a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServerlessServiceListClustersRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceListClusters(ctx context.Context) ApiServerlessServiceListClustersRequest {
	return ApiServerlessServiceListClustersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1ListClustersResponse
func (a *ServerlessServiceAPIService) ServerlessServiceListClustersExecute(r ApiServerlessServiceListClustersRequest) (*TidbCloudOpenApiserverlessv1beta1ListClustersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1ListClustersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceListClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "", "")
	}
	if r.pageToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageToken", r.pageToken, "", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "", "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServiceListRegionsRequest struct {
	ctx        context.Context
	ApiService *ServerlessServiceAPIService
}

func (r ApiServerlessServiceListRegionsRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1ListRegionsResponse, *http.Response, error) {
	return r.ApiService.ServerlessServiceListRegionsExecute(r)
}

/*
ServerlessServiceListRegions Provides a list of available regions for TiDB Serverless clusters.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServerlessServiceListRegionsRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServiceListRegions(ctx context.Context) ApiServerlessServiceListRegionsRequest {
	return ApiServerlessServiceListRegionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1ListRegionsResponse
func (a *ServerlessServiceAPIService) ServerlessServiceListRegionsExecute(r ApiServerlessServiceListRegionsRequest) (*TidbCloudOpenApiserverlessv1beta1ListRegionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1ListRegionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServiceListRegions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/regions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServerlessServicePartialUpdateClusterRequest struct {
	ctx              context.Context
	ApiService       *ServerlessServiceAPIService
	clusterClusterId string
	body             *V1beta1ServerlessServicePartialUpdateClusterBody
}

func (r ApiServerlessServicePartialUpdateClusterRequest) Body(body V1beta1ServerlessServicePartialUpdateClusterBody) ApiServerlessServicePartialUpdateClusterRequest {
	r.body = &body
	return r
}

func (r ApiServerlessServicePartialUpdateClusterRequest) Execute() (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	return r.ApiService.ServerlessServicePartialUpdateClusterExecute(r)
}

/*
ServerlessServicePartialUpdateCluster Partially updates a specific TiDB Serverless cluster.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterClusterId Output_only. The unique ID of the cluster.
	@return ApiServerlessServicePartialUpdateClusterRequest
*/
func (a *ServerlessServiceAPIService) ServerlessServicePartialUpdateCluster(ctx context.Context, clusterClusterId string) ApiServerlessServicePartialUpdateClusterRequest {
	return ApiServerlessServicePartialUpdateClusterRequest{
		ApiService:       a,
		ctx:              ctx,
		clusterClusterId: clusterClusterId,
	}
}

// Execute executes the request
//
//	@return TidbCloudOpenApiserverlessv1beta1Cluster
func (a *ServerlessServiceAPIService) ServerlessServicePartialUpdateClusterExecute(r ApiServerlessServicePartialUpdateClusterRequest) (*TidbCloudOpenApiserverlessv1beta1Cluster, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TidbCloudOpenApiserverlessv1beta1Cluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServerlessServiceAPIService.ServerlessServicePartialUpdateCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/clusters/{cluster.clusterId}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster.clusterId"+"}", url.PathEscape(parameterValueToString(r.clusterClusterId, "clusterClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v GooglerpcStatus
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
